<style>
  pre, td { margin: 0 !important; padding: 0 !important; }
</style>
<pre style="overflow: auto"><table><tr><td><pre>















1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53

</pre></td><td><pre>#include &lt;ctype.h&gt;
#include &lt;errno.h&gt;
#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;tgmath.h&gt;

/* (c) 1964
- This has been tested with clang and gcc. Make sure to compile with `-lm`.
- Undefined behavior is not allowed. Other compiler warnings are okay to ignore.
- All array entries except the final sentinel are to be set to a nonzero value.
- Counting comments as one, there are ten types of thing in this puzzle.
*/

int main() {
    , ++P
    typedef
    typedef
    (!&amp;N); continue; }
    *P /* The value set here is a float that might not look exact, but will still pretty clearly give the letter S in the end. */
    *P = 10 +
    *P = 10 +
    +raise(9)
    +rand())[&amp;F]);
    +rand())[&amp;F]);
    -0; *P /=
    -0; *P /=
    /* At this time, 5 out of 22 array entries should be set to their final values. */ *F;
    while (*(++P));
    '}' - '{'; *(P
    ((isxdigit(*F) * /* The final program should not end up showing nondeterministic behavior. */
    *(P += 4); /* At this time, P should point to the last meaningful array entry. */
    *F - *P / 30);
    + '\x13') = (N = ' ',
    -0.795 * *F + sqrt(
    0[&amp;Y]; } while
    I; *(F - ~(int) (
    % 69; *P /= fabs((float)
    /* The first array entry is used as scratch space, and so is one of the only entries that will be modified more than once. */ N = 41}; F[
    /* This entry, around the middle of the array, is being set to its final value. */ N -= 32] = *F;
    = *F * log10((int) trunc(
    = 9. / N; P -= (int)
    F[3] = *F; /* The value set here will, after the end of the program, be read as the letter E. */
    float F[23] = {Y =
    long time(); 0xe5cap3 void
    ~(int) asinh(*P); ++P;
    /* The code up to here has run pretty normally, */ float T; T /* but this will soon no longer be true. */
    (*(F + 16) = *(F + lround(*F - tan(
    -8, *P = (abs(*P) &lt;&lt; abs(*P))
    -8, *P = (abs(*P) &lt;&lt; abs(*P))
    0[&amp;N]; if(&amp;Y) do { *P -=
    Y)); N--; Z = ~-(--P - F) + N *
    Y)); N--; Z = ~-(--P - F) + N *
    free() volatile sin(); restrict exit() /* Uh-oh. */
    int N; float Y; complex Z;
    lround(*P)) + 3 ** P - !exit * (long) (
    58)))) / *F + 13)) = *P * tan(208); *F =
    log(*P)); *(P + 4) = *P + /* The value set here will, after the end of the program, be read as the letter N. */ *F -
    ); F[--N] = *(P - &Y + &N) / *F + *(P + 0xf); exit;
    )[N] = F[-~N]; Y = F[N--] = *F * 0x1.a895dp0; (exit
    , F[--N] = *F + 0x1.b1aep21 / (0xdead + 0xbeef + 0xcafe + 0xf00d)), exit
    , F[--N] = ++N + N-- / (++P - P--) + *P - 0x.accp4, exit
    18[F] = 1[F] = P[~-N] - (N ^ 12); Y
    ; F[--N] = *F = 0x.9b3p5; exit - exit + exit - exit + exit,
    Z += N-- - (F - --P); *(F + N) = Z++ / ~-N; N++; (P
    Z -= N++; errno[P++] = *(F + -~N); *P = --Z / ~-N; (P++[N] = (
    ) = *(F + 'b' - Y * '5') /* Parse the extraction as follows: */ = *F /* ???? ?? ???? ? ?????? ???? ? (N), */ = *F /* using the current value of N at this time. */ = *F = *F + '\0'; P -= '\x4';
    -81 + (*F + sin(*F - cos(*F - tan(*F - fabs(*F))))); /* This line sets two array entries to their final values, */ if(*P == 0x0) *P = fabs((0x.29c2p0 * *F) * Z) - *F; --P; /* for a total of 18 out of 22. */ Z *= .638424 *
}
</pre></td></tr></table></pre>
<button id="clipboard-button"></button>
